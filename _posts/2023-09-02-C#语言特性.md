---
layout: post
title: C#语言特性
categories: [Net, C#]
description: 收集CSharp常用语言特性
keywords: Net, C#, CSharp
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
文章收录.net各版本的常用语言特性。
### 全局命名空间引用 C# 10
```csharp
global using System;
global using System.Linq;
```
> 最佳使用方法，在项目定义一个单独`GlobalUsings.cs`文件引用于不同项目中

系统默认定义的全局引用文件,自动生成在`Vocabulary.GlobalUsing.g.cs`中，在.net 6.0中默认内容为：
```csharp
// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
```
上面默认生成，可以修改项目文件来进行调整，如：
```csharp
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  <ItemGroup>
    <Using Remove="System.Threading" />
    <Using Include="System.Numerics" />
  </ItemGroup>
</Project>
```

通过这样定制为生成内容如下：
```csharp
// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading.Tasks;
global using global::System.Numerics;
```

也可以通过，修改项目文件，来禁用默认生成内容，如：
```csharp
<ImplicitUsings>disable</ImplicitUsings>
```

### 数值比较
double,float不能进行精确比较，只能采用减法进行精度比较，要进行精确比较，使用int,long,uint,ulong,decimail

数值类型|示例
-|-
double|0.15d
float|0.23f
decimail|2.6m
long|-5l
ulong|1ul

数据值可以加入`_`用于数字分隔，如`6_6`和`66`,都表示66

### 平台不支持API处理
下面的代码在macOS上执行就会抛出异常
```csharp
try
{
  CursorSize = int.Parse(args[2]);
}
catch (PlatformNotSupportedException)
{
  WriteLine("The current platform does not support changing the size of the cursor.");
}
```

#### 平台判断代码
```csharp
if (OperatingSystem.IsWindows())
{
  // execute code that only works on Windows
}
else if (OperatingSystem.IsWindowsVersionAtLeast(major: 10))
{
  // execute code that only works on Windows 10 or later
}
else if (OperatingSystem.IsIOSVersionAtLeast(major: 14, minor: 5))
{
  // execute code that only works on iOS 14.5 or later
}
else if (OperatingSystem.IsBrowser())
{
  // execute code that only works in the browser with Blazor
}
```

#### 采用条件编译

Target Framework| Symbols
-|-
.NET Standard| NETSTANDARD2_0, NETSTANDARD2_1, and so on
Modern .NET| NET6_0, NET6_0_ANDROID, NET6_0_IOS, NET6_0_WINDOWS, and so on

使用样例
```csharp
#if NET6_0_ANDROID
// compile statements that only works on Android
#elif NET6_0_IOS
// compile statements that only works on iOS
#else
// compile statements that work everywhere else
#endif
```

### switch表达式 C# 8.0
```csharp
message = s switch
{
  FileStream writeableFile when s.CanWrite
    => "The stream is a file that I can write to.", 
  FileStream readOnlyFile
    => "The stream is a read-only file.", 
  MemoryStream ms
    => "The stream is a memory address.", 
  null
    => "The stream is null.",
  _
    => "The stream is some other type."
};
WriteLine(message);
```
```csharp
//计算Fib
static int FibFunctional(int term) => 
  term switch
  {
    1 => 0,
    2 => 1,
    _ => FibFunctional(term - 1) + FibFunctional(term - 2)
  };
```


### Catch Exception with filters
```csharp
Write("Enter an amount: ");
string? amount = ReadLine();
try
{
  decimal amountValue = decimal.Parse(amount);
}
catch (FormatException) when (amount.Contains("$"))
{
  WriteLine("Amounts cannot use the dollar sign!");
}
catch (FormatException)
{
  WriteLine("Amounts must only contain digits!");
}
```


### tuples
函数用于返回多个值
```csharp
public (string, int) GetFruit()
{
  return ("Apples", 5);
}


(string, int) fruit = bob.GetFruit();
WriteLine($"{fruit.Item1}, {fruit.Item2} there are.");
```

#### Naming the fields of a tuple(命名tuple)
```csharp
public (string Name, int Number) GetNamedFruit()
{
  return (Name: "Apples", Number: 5);
}
```

```csharp
var fruitNamed = bob.GetNamedFruit();
WriteLine($"There are {fruitNamed.Number} {fruitNamed.Name}.");
```

#### Deconstructing tuples
```
// store return value in a tuple variable with two fields
(string TheName, int TheNumber) tupleWithNamedFields = bob.GetNamedFruit();
// tupleWithNamedFields.TheName
// tupleWithNamedFields.TheNumber
// deconstruct return value into two separate variables
(string name, int number) = GetNamedFruit();
// name
// number
```

### index 定义
```csharp
// indexers
public Person this[int index]
{
  get
  {
    return Children[index]; // pass on to the List<T> indexer
  }
  set
  {
    Children[index] = value;
  }
}
```
### 使用record定义不可变类型
```csharp
public record ImmutableVehicle
{
  public int Wheels { get; init; }
  public string? Color { get; init; }
  public string? Brand { get; init; }
}
```
简化定义
```csharp
// simpler way to define a record
// auto-generates the properties, constructor, and deconstructor
public record ImmutableAnimal(string Name, string Species);
```

### 集合排序
如果对象实现了接口:
```csharp
namespace System
{
  public interface IComparable
  {
    int CompareTo(object? obj);
  }
  public interface IComparable<in T>
  {
    int CompareTo(T? other);
  }
}
```

通过方法`Array.Sort`进行排序
```csharp
Person[] people =
{
  new() { Name = "Simon" },
  new() { Name = "Jenny" },
  new() { Name = "Adam" },
  new() { Name = "Richard" }
};
WriteLine("Initial list of people:"); 
foreach (Person p in people)
{
  WriteLine($"  {p.Name}");
}
WriteLine("Use Person's IComparable implementation to sort:");
Array.Sort(people);
foreach (Person p in people)
{
  WriteLine($"  {p.Name}");
}
```
如果`People`没有实现上述接口，会抛出如下异常：
```csharp
Unhandled Exception: System.InvalidOperationException: Failed to compare 
two elements in the array. ---> System.ArgumentException: At least one 
object must implement IComparable.
```

有两种方法解决此问题
- 方案一： `People`类型实现接口
    ```csharp
    public class Person : object, IComparable<Person>
    ```
- 方案二:使用`IComparer<T>`接口，在其他类实现排序算法
    ```csharp
    public class PersonComparer : IComparer<Person>
    {
      public int Compare(Person? x, Person? y)
      {
        if (x is null || y is null)
        {
          return 0;
        }
        // Compare the Name lengths...
        int result = x.Name.Length.CompareTo(y.Name.Length);
        // ...if they are equal...
        if (result == 0)
        {
          // ...then compare by the Names...
          return x.Name.CompareTo(y.Name);
        }
        else // result will be -1 or 1
        {
          // ...otherwise compare by the lengths.
          return result; 
        }
      }
    }
    ```
    使用方式
    ```csharp
    WriteLine("Use PersonComparer's IComparer implementation to sort:"); 
    Array.Sort(people, new PersonComparer());
    foreach (Person p in people)
    {
      WriteLine($"  {p.Name}");
    }
    ```
### 检查对象null
```csharp
// check that the variable is not null before using it
if (thisCouldBeNull != null)
{
  // access a member of thisCouldBeNull
  int length = thisCouldBeNull.Length; // could throw exception
  ...
}
```
C# 7 introduced is combined with the ! (not) operator as an alternative to !=, as shown in the 
following code:
```csharp
if (!(thisCouldBeNull is null))
{
```
C# 9 introduced is not as an even clearer alternative, as shown in the following code:
```csharp
if (thisCouldBeNull is not null)
{
```
If you are trying to use a member of a variable that might be null, use the null-conditional 
operator ?., as shown in the following code:
```csharp
string authorName = null;
// the following throws a NullReferenceException
int x = authorName.Length;
// instead of throwing an exception, null is assigned to y
int? y = authorName?.Length;
```

### 扩展方法
```csharp
public class StringExtensions
{
  public static bool IsValidEmail(string input)
  {
    // use simple regular expression to check
    // that the input string is a valid email
    return Regex.IsMatch(input,
      @"[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+");
  }
}
```
### C#类型与.net types
Keyword|.NET type|Keyword|.NET type
-|-|-|-
string|System.String|char|System.Char
sbyte|System.SByte| byte| System.Byte
short|System.Int16| ushort| System.UInt16
int| System.Int32| uint| System.UInt32
long| System.Int64| ulong| System.UInt64
nint| System.IntPtr| nuint| System.UIntPtr
float| System.Single| double| System.Double
decimal|System.Decimal| bool| System.Boolean
object| System.Object| dynamic| System.Dynamic.DynamicObject

### Common.NET Types

#### 数值型
命名空间|类型示例|说明
-|-|-
System |SByte, Int16, Int32, Int64 |Integers; that is, zero and positive and negative whole numbers
System| Byte, UInt16, UInt32, UInt64 |Cardinals; that is, zero and positive whole numbers
System| Half, Single, Double |Reals; that is, floating-point numbers
System| Decimal Accurate |reals; that is, for use in science, engineering, or financial scenarios
System.Numerics| BigInteger, Complex, Quaternion |Arbitrarily large integers, complex numbers, and quaternion numbers

