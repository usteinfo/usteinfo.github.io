---
layout: post
title: .Net 并发编程
categories: [多线程, Net]
description: 本文描述并发编程的核心概念，在 .Net 各版本中并发编程的技术的发展变化，同时列出一些最佳实践内容。
keywords: 多线程, Net,异步
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

本文描述并发编程的核心概念，在 .Net 各版本中并发编程的技术的发展变化，同时列出一些最佳实践内容。

### 一、概述

在 .NET 中，实现并发编程有多种方式。以下是一些常用的并发编程技术和类： 
 
1. 线程（Thread）：通过创建多个线程，您可以同时执行多个任务。然而，在使用线程时需要小心处理线程同步和共享资源的问题，以避免竞态条件和数据不一致的问题。 
 
2. 任务并行库（Task Parallel Library，TPL）：TPL 是 .NET Framework 中的一个高级并发编程模型。它建立在线程之上，提供了更高级别的抽象，使并发编程更加简单。您可以使用 Task 类来表示一个可执行的任务，并使用 Parallel 类提供的方法来并行执行任务。 
 
3. 异步编程（Asynchronous Programming）：通过使用 async 和 await 关键字，您可以以异步的方式执行耗时的操作，而不会阻塞主线程。异步编程使您能够更好地利用系统资源，提高应用程序的响应性。 
 
4. 并发集合（Concurrent Collections）：.NET 提供了一些并发集合类，如 ConcurrentQueue、ConcurrentStack 和 ConcurrentDictionary，用于在多个线程之间安全地共享数据。这些集合类提供了线程安全的操作，避免了手动处理同步的复杂性。 
 
5. 锁（Locking）：在多线程编程中，锁是一种常用的同步机制，用于保护共享资源。通过使用 lock 关键字，您可以确保在某个线程访问共享资源时，其他线程无法同时访问该资源。 

### 二、.Net 并发编程发展过程

1. .NET Framework 1.0/1.1：最初的 .NET Framework 版本提供了基本的线程支持，可以使用 Thread 类来创建和管理线程。但是，开发人员需要手动处理线程同步和共享资源的问题。 
 
2. .NET Framework 2.0：引入了 ThreadPool 类，它提供了一种更高级别的线程管理机制。ThreadPool 可以自动管理线程的创建和回收，并提供了一些方法来调度任务。 
 
3. .NET Framework 4.0：引入了任务并行库（Task Parallel Library，TPL）。TPL 提供了更高级别的抽象，使并发编程更加简单。您可以使用 Task 类来表示一个可执行的任务，并使用 Parallel 类提供的方法来并行执行任务。 
 
4. .NET Framework 4.5：引入了 async/await 关键字，支持异步编程。通过使用 async 和 await，您可以以异步的方式执行耗时的操作，而不会阻塞主线程。这使得编写异步代码更加简单和直观。 
 
5. .NET Framework 4.5.1/4.5.2：在这些版本中，引入了一些新的并发集合类，如 ConcurrentQueue、ConcurrentStack 和 ConcurrentDictionary。这些集合类提供了线程安全的操作，避免了手动处理同步的复杂性。 
 
6. .NET Framework 4.6/4.6.1/4.6.2：这些版本主要集中在性能和可靠性的改进上，并没有引入新的主要并发编程技术。 
 
7. .NET Core/.NET 5+：在 .NET Core 和 .NET 5+ 中，继续支持之前版本的并发编程技术，同时还引入了一些新的功能和改进。例如，通过引入 ValueTask 类型来减少异步操作的堆分配，以提高性能。 

版本|功能
-|-
.Net 4.0 | 任务并行库, 线程安全的集合类,并行linq
.Net 4.5 | async await关键字
.Net 4.5.1 | async 调试支持
C# 6 |在catch和finally 中实现 await 
C# 7.x and .net core 2.0|ValueTask,ValueTask<TResult>,_(弃元)，Main增加async
C#8.0 and .net core 3.0| 新增 async streams,IAsyncEnumerable,IAsyncDisposable
C# 10 and .net 6| support IAsyncEnumerable<T> responses in the ASP.NET Core MVC controller methods

### 三、托管线程

在 .NET 中，托管线程（Managed Thread）是由公共语言运行时（CLR）创建和管理的线程。这些线程也被称为CLR线程或托管执行上下文。 
 
与传统线程相比，托管线程提供了更高级别的并发编程抽象。它们使用.NET框架提供的类和API进行创建和管理，例如Thread类。 
 
.NET中的托管线程具有以下几个优点： 
 
1. 自动内存管理：托管线程受CLR提供的自动内存管理的好处。它们不需要手动进行内存分配或释放。 
 
2. 异常处理：在托管线程中抛出的异常可以使用try-catch块捕获和处理，从而实现更强大的错误处理。 
 
3. 同步和协调：.NET提供了各种同步原语，如锁、互斥体和信号量，可用于在托管线程之间协调对共享资源的访问。 
 
4. 线程池：.NET包括一个线程池，用于管理一组工作线程。您可以将工作项提交给线程池，而不是为每个任务创建和销毁线程，线程池会在可用线程上高效地执行这些任务。 

##### 前台线程和后台线程

1. 前台线程： 
前台线程是 .NET 中的默认线程类型。当主应用程序线程（也称为主线程）启动时，它会自动被标记为前台线程。前台线程会保持应用程序的运行，直到它们完成执行。 
 
前台线程被认为对应用程序很重要，应用程序会等待它们完成才会退出。如果任何前台线程仍在运行，CLR 会保持应用程序的运行。 
 
2. 后台线程： 
后台线程被认为对应用程序的执行不太关键。当所有前台线程完成执行后，CLR 不会等待后台线程完成。如果只有后台线程在运行，CLR 会终止应用程序，即使后台线程尚未完成工作。 
 
后台线程通常用于不是应用程序主要功能的任务，或者可以独立运行而不影响应用程序终止的任务。 
 
在 .NET 中，可以使用 Thread 类的 IsBackground 属性将线程设置为后台线程。使用 Thread 类创建的线程默认为前台线程，除非使用 IsBackground 属性显式设置为后台线程。 

##### 线程的状态

`ThreadState`只读属性的，提供当前线程的状态

状态|说明
-|-
Aborted|线程已终止
AbrotRequested|线程终止请求发出后，还未执行完成
Running|正常运行
Stoppped|已停止
StopRequested|线程停止请求发出后，还未执行完成
Suspended|线程挂起
SuspendRequested|线程挂起请求发出后，还未执行完成
Unstarted|线程已创建，未开始执行
WatiSleepJoin|线程阻塞

`Thread.IsAlive`表示线程启动后，未被停止或终止时，此属性返回true

`Thread.Name`:默认值为null,只能设置一次

##### 线程的创建和回收

- 线程创建
    ```csharp
        public Thread(ParameterizedThreadStart start);
        public Thread(ThreadStart start);
        public Thread(ParameterizedThreadStart start, int maxStackSize);
        public Thread(ThreadStart start, int maxStackSize);
    ```
    
- 线程暂停 

    `Thread.Sleep`,输入一个数量表示，休息的毫秒数，可以传递特殊值`Timeout.Infinite`表示无限期，此场景只有被终止和阻塞（`Thread.Interrupt`）

- 线程回收

    .net 6.0不再支持`Thread.Abort`方法，如果有强制终止线程的要求，推荐的方式是在其他进展使用`Process.Kill`进行处理;应用中线程的终止，采用CancellationToken

- 线程异常

    ThreadInterruptedException，ThreadStartException，ThreadStateException
    
##### 线程数据同步

线程数据同步常用方法为使用lock关键字
- 使用lock关键字
    
    ```csharp
    lock(order) {
        order.AddDetails(orderDetail);
    }
    //上面的代码等效为：
    try {
        Monitor.Enter(order);
        order.AddDetails(orderDetail);
    } finally {
        Monitor.Exit(order);
    }
    ```
    
 - Interlocked类，也提供几个原子性的操作方法
    
    方法|说明
    -|-
    Add|替换第一次操作数据值为两个输入操作数的和
    And|提供操作数据位与，与Add类似
    CompareExchange|比较两个对象，相等的情况下，替换第一个
    Decrement|原子减少整形数据1
    Exchange|设置变量为新值
    Increment|原子加整形数据1
    Or|两个数值的按位或操作
    
    示例
    ```csharp
    static void Main(string[] args)
        {
            int a = 5;
            int b = 3;
            //a==5 设置a=b=3
            var c =  Interlocked.CompareExchange(ref a, b,5);
            Console.WriteLine(a);
            Console.WriteLine(c);
            Console.ReadLine();
        }
    ```

- 手动同步

    多线程中，需要共享的数据，包括全局字段，静态字段，实例字段，这此内容不能使用代码块进行包裹
    
    实现方式一：
    ```csharp
    private static Mutex orderMutex = new Mutex();
    ...
    orderMutex.WaitOne(500); //500为超时时间
    order.AddDetails(orderDetail);
    orderMutex.ReleaseMutex();
    ...
    ```
    方式二（多读，不写）ReaderWriterLockSlim：
    ```csharp
    public class ContactListManager
    {
        private readonly List<Contact> contacts;
        private readonly ReaderWriterLockSlim contactLock = 
            new ReaderWriterLockSlim();
        public ContactListManager(List<Contact> initialContacts)
        {
            contacts = initialContacts;
        }
        //写，只能单线程进入
        public void AddContact(Contact newContact)
        {
            try
            {
                contactLock.EnterWriteLock();
                contacts.Add(newContact);
            }
            finally
            {
                contactLock.ExitWriteLock();
            }
        }
        //读取可以多个进入
        public Contact GetContactByPhoneNumber(string 
            phoneNumber)
        {
            try
            {
                contactLock.EnterReadLock();
                return contacts.FirstOrDefault(x => 
                    x.PhoneNumber == phoneNumber);
            }
            finally
            {
                contactLock.ExitReadLock();
            }
        }
    }
        
    ```
    
- 安全的并发集合，命名空间：System.Collections.Concurrent

##### System.Timers.Timer与System.Threading.Timer区别
- System.Timers.Timer:Elapsed事件，Interval用于设置定时时间，Enabled表示是否启用，AutoReset属性，如果为false表示执行完成后，不重置,频繁开关闭环境使用
- System.Threading.Timer:TimerCallback作为回调事件
    ```csharp
    private void InitializeTimer()
    {
        var updater = new MessageUpdater();
        // 第一个参数是：回调方法，表示要定时执行的方法，
        // 第二个参数是：回调方法要使用的信息的对象，或者为空引用，
        // 第三个参数是：调用 callback 之前延迟的时间量（以毫秒为单位），指定 Timeout.Infinite 以防止计时器开始计时。指定零 (0) 以立即启动计时器。
        // 第四个参数是：定时的时间时隔，以毫秒为单位
        _timer = new System.Threading.Timer(
        callback: new TimerCallback(TimerFired),
        state: updater,
        dueTime: 500,
        period: 1000);
    }
    ```

System.Threading.Timer 是C# 中的一个定时器，可以定时（不断循环）执行一个任务。它是在线程上执行的，具有很好的安全性。为此  .Net Framework 提供了5个重载的构造器方法。官网的文档是这样解释的：

System.Threading.Timer 是一个简单、 轻型计时器，它使用回调方法，并由线程池线程提供服务。 但不建议使用 Windows 窗体，因为它的回调不会在用户界面线程上发生。 System.Windows.Forms.Timer 是使用 Windows 窗体的更好选择。 对于基于服务器的计时器的功能，您可以考虑使用 System.Timers.Timer, 它将引发事件，并具有附加功能。

　　
只要您使用 Timer, ，则必须保持对它的引用。 与任何托管对象一样 Timer 没有引用时才进行垃圾收集。 这一事实， Timer 是仍活动不会阻止它正在收集。

　　
当不再需要一个计时器时，使用 Dispose 计时器持有方法来释放资源。 请注意，回调可能发生后 Dispose() 已调用方法重载，因为计时器是按线程池线程来安排回调的执行。 您可以使用 Dispose(WaitHandle) 方法重载来等待，直到所有回调都已都完成。

　　
执行由计时器的回调方法应可重入，因为它在调用 ThreadPool 线程。 回调可同时执行两个线程池线程上的计时器间隔是否小于执行回调，所需的时间或者是否所有线程池线程都正在使用，并且回调被多次排队。

### 四、并行子线程与父线程

使用`Task.Factory.StartNew()`启动线程，启动时，子线程和主线程都可以输入参数：TaskCreationOptions.AttachedToParent

参数|主线程|子线程|结果
-|-|-|-
AttachedToParent|true|X|主线程等待子线程结束
AttachedToParent|false|X|主线程不等待子线程结束

##### 并行编程误区
- 使用并行编程，不一定能保证并行性
- 并行运行，不会保证快速，如果处理过程中，有慢处理应用
- 阻塞UI线程，在UI线程中使用，Parallel.For,Parallel.ForEach,应使用Task.Run包装
- 线程安全，确认只调用.net中线程安全的方法，限制调用静态方法在线程中，确认是线程安全
- 并行编程中不访问UI控件

##### Task Parallel Library (TPL) 
**Task Parallel Library (TPL) dataflow library**实现生产/消费的设计模式，此部分不是.net runtime或sdk的一部分

核心概念
- ISourceBlock<TOutput>：读取数据
- ITargetBlock<TInput>：数据接收
- IPropagatorBlock<TInput, TOutput>:读取和写入数据

DataflowMessageStatus

状态|备注
-|-
Accepted|消息已确认，将被处理
Declined|消息被目标拒绝，源只有在此消息被其他目标处理后，才会处理其他消息
DecliningPermanently|消息被目标拒绝，没有目标可处理此消息。当前目标会拒绝所有随后所有消息。源将断开与目标的连接
Postponed|延期确认. 
NotAvailable|消息无效

###### Buffering blocks

类型|数据源|目标|说明
-|-|-|-
BufferBlock<T>|多|多|异步队列，实现FIFO，一个消息只有一个目标处理，成功处理后，消息移除
BroadcastBlock<T>||多|相似于BufferBlock<T>，只为目标提供最新的消息。消息被接收后不会删除
WriteOnceBlock<T>|||

###### Execution blocks

类型|数据源|目标|说明
-|-|-|-
ActionBlock<TInput>|||当操作完成，或任务完成，表示处理完成
TransformBlock<TInput, TOuput>||多|
TransformManyBlock<TInput,TOutput>|||


###### Grouping blocks

类型|数据源|目标|说明
-|-|-|-
BatchBlock<T>|||
JoinBlock<T1, T2>|||
BatchedJoinBlock<T1, T2>|||

##### 并行 LINQ

`System.Linq.ParallelEnumerable`

- AsParallel,返回并行linq
- AsSequential,返回串行linq

AsOrdered,如果有排序要求，按下面示例调用

```csharp
var results = people.AsParallel().AsOrdered()
    .Where(p => p.LastName.StartsWith("H"));
```

AsUnordered

```csharp
var results = people.AsParallel().AsUnordered()
    .Where(p => p.LastName.StartsWith("H"));
```

ForAll,的性能优于Parallel.ForEach，延期执行，处理数据分段，在最后合并一次

异常AggregateException，try/catch标准用法

```
internal void ProcessAdultsWhoVoteWithPlinq
    (List<Person> people)
{
    try
    {
        var adults = people.AsParallel().Where(p =>
            p.Age > 17);
        adults.ForAll(ProcessVoterActions);
    }
    catch (AggregateException ae)
    {
        foreach (var ex in ae.InnerExceptions)
        {
            Console.WriteLine($"Exception encountered while processing voters. Message:                    {ex.Message}");
        }
    }
}
```

在 .NET 中，使用  SpinLock  类可以实现自旋锁（Spin Lock）。自旋锁是一种用于保护共享资源免受多个线程并发访问的同步机制。与其他锁机制不同，自旋锁在遇到争用时不会让线程进入休眠状态，而是反复检查锁是否可用，以自旋的方式等待获取锁。 

```csharp
private SpinLock _spinLock = new SpinLock();
internal void ProcessAdultsWhoVoteWithPlinq2(List<Person> 
    people)
{
    var adults = people.AsParallel().Where(p => p.Age > 17);
    adults.ForAll(ProcessVoterActions2);
}
private void ProcessVoterActions2(Person adult)
{
    var hasLock = false;
    if (adult.Age > 120)
    {
        try
        {
            _spinLock.Enter(hasLock);
            adult.Age = 120;
        }
        finally
        {
            if (hasLock) _spinLock.Exit();
        }
    }
}

```

### 五、最佳实践
##### 1、静态对象
- 静态数据和构造函数，静态构造函数执行时，会阻塞线程执行，此过程是线程安全的初始化静态数据
- 关键字lock，可以锁定一个代码块线程安全
- ThreadStatic特性，此特性可用于静态字段，每个线程都会有不同的变量，但在线程池中应用时，要注意退出或进入时，对此值进行初始化
- 单例，双重检测锁定实现，静态构造函数


##### 2、线程数据限制

`Parallel.ForEach`可以通过提供`ParallelOptions`参数用于限制线程数据使用，如：

```csharp
public void ProcessParallelForEachWithLimits
    (List<string> items)
{
    int max = Environment.ProcessorCount > 1 ? 
                Environment.ProcessorCount / 2 : 1;
    var options = new ParallelOptions
    {
        MaxDegreeOfParallelism = max //线程数
    };
    Parallel.ForEach(items, options, y => {
        // Process items
    });
}
```

PLINQ限制线程数

```csharp
public bool ProcessPlinqWithLimits(List<string> items)
{
    int max = Environment.ProcessorCount > 1 ? 
        Environment.ProcessorCount / 2 : 1;
    return items.AsParallel()
        .WithDegreeOfParallelism(max) //线程数
        .Any(i => CheckString(i));
}
```

##### 3、线程池大小调整
`ThreadPool.SetMaxThreads`, 可以调整最大工作线程数`workerThreads`和异步io线程数据`completionPortThreads`

```csharp
private void UpdateThreadPoolMax()
{
    ThreadPool.GetMinThreads(out int workerMin, out int 
        completionMin);
    int workerMax = GetProcessingMax(workerMin);
    int completionMax = GetProcessingMax(completionMin);
    ThreadPool.SetMaxThreads(workerMax, completionMax);
}
private int GetProcessingMax(int min)
{
    return min < Environment.ProcessorCount ?
                    Environment.ProcessorCount * 2 :
                    min * 2;
}
```

线程饥饿，太多线程由于阻塞，造成无线程可用，公共建议
- Locks,太多线程急用相同的共享资源，分析代码减少此种场景
- No async/await:Asp.net Core中所有Controller方法都标记为async
- 太多线程池线程，太多空闲线程需要处理
- 不要使用Thread.Suspend 和 Thread.Resume控制线程的执行顺序，应使用 locking算法和Task.ContinueWith

##### 4、UI响应和线程

后台线程的执行场景
- 写日志和分析数据
- 监控网络和文件系统资源
- 读取数据到应用程序

不适用场景：
- 保存应用状态
- 执行数据库事务
- 应用数据处理

后台线程创建方式
- 设置线程IsBackground属性为true
- ThreadPool中的线程
- TPL启用的线程

线程池的使用

```csharp
ThreadPool.QueueUserWorkItem(GetCurrentOrders);
```

Task.Run

```csharp
Task.Run(someAction);
//等同于
Task.Factory.StartNew(someAction,
    CancellationToken.None, 
    TaskCreationOptions.DenyChildAttach, 
    TaskScheduler.Default);
```

Task.Factory.StartNew

```csharp
Task<List<Order>> currentOrdersTask = 
Task.Factory.StartNew(GetCurrentOrders, 
    CancellationToken.None, 
    TaskCreationOptions.AttachedToParent, 
    TaskScheduler.Default);
```

线程中更新UI
```csharp
//wpf
Application.Current.Dispatcher.Invoke(new Action(() => { 
    usernameTextBox.Text = "John Doe";
}));

//winform
    private void UpdateUsername()
    {
        var updateAction = new Action(() =>
        {
            usernameTextBox.Text = "John Doe";
        });
        
        if (this.InvokeRequired)
        {
            this.Invoke(updateAction);
        }
        else
        {
            updateAction();
        }
    }
```

##### 5、异步编程

- IO密集，网络和磁盘
- CPU密集，内存和cpu操作

最佳实践
- 在同步方法中应用关键字：async,await;少用Wait和Result
- 少用Task.WhenAll,应直接使用await
- 不要使用async void,应使用 async Task Task<TResult> ValueTask ValueTask<TResult>.一个特例就是在事件handlers中可以使用async void,.Net 6中main方法可标注为async
- 不要汇合阻塞代码和异步代码，使用async调用异步代码
- 在不使用附加参数时，使用Task.Run代替Task.Factory.StartNew
- 长时间运行的异步方法应支持CancellationToken
- 共享数据的多线程访问应加入线程同步
- 总是在IO和网络访问使用async await
- 同步方法和异步方法在命名上要有所有区别，所有异步方法以Async结尾
- async异步方法中，不要使用Thread.Sleep,正确应使用 await task.Delay
- I/O密集适合异步操作，但不适合并发操作：文件、数据库、网络调用,async,await
- CPU密集：如果只有少量并行，可以使用Parallel.Invoke代替Parallel.For、Parallel.ForEach

Parallel.For

```csharp
Parallel.For(0, files.length, index => {
    FileInfo fi = new (files[index]);
    ...
});

```

Parallel loops with thread-local variables

```csharp
public static FileData GetInfoForFilesThreadLocal(string[] 
    files)
{
    var results = new FileData();
    var fileInfos = new List<FileInfo>();
    long totalFileSize = 0;
    DateTime lastWriteTime = DateTime.MinValue;
    string lastFileWritten = "";
    object dateLock = new();
    //subtotal 为thread-local
    Parallel.For<long>(0, files.Length, () => 0,
        (index, loop, subtotal) => {
            FileInfo fi = new(files[index]);
            long size = fi.Length;
            DateTime lastWrite = fi.LastWriteTimeUtc;
            lock (dateLock)
            {
                if (lastWriteTime < lastWrite)
                {
                    lastWriteTime = lastWrite;
                    lastFileWritten = fi.Name;
                }
            }
            subtotal += size;
            fileInfos.Add(fi);
            return subtotal;
            },
        (runningTotal) => Interlocked.Add(ref
        totalFileSize, runningTotal)
    );
    results.FileInfoList = fileInfos;
    results.TotalSize = totalFileSize;
    results.LastFileWriteTime = lastWriteTime;
    results.LastWrittenFileName = lastFileWritten;
    return results;
}

```

Parallel.ForEach

```csharp
private static Bitmap ConvertJpgToBitmap(string fileName)
{
    Bitmap bmp;
    using (Stream bmpStream = File.Open(fileName, FileMode.Open))
    {
        Image image = Image.FromStream(bmpStream);
        bmp = new Bitmap(image);
    }
    return bmp;
}
public static List<Bitmap> ConvertFilesToBitmaps(List<string> files)
{
    var result = new List<Bitmap>();
    Parallel.ForEach(files, file =>
    {
        FileInfo fi = new(file);
        string ext = fi.Extension.ToLower();
        if (ext == ".jpg" || ext == ".jpeg")
        {
            result.Add(ConvertJpgToBitmap(file));
        }
    });
    return result;
}

```

Parallel.ForEachAsync(.net 6.0)

```csharp
public static async Task<List<Bitmap>>
    ConvertFilesToBitmapsAsync(List<string> files, CancellationTokenSource cts)
{
    ParallelOptions po = new()
    {
        CancellationToken = cts.Token,
        MaxDegreeOfParallelism =
            Environment.ProcessorCount == 1 ? 1
                      : Environment.ProcessorCount - 1
    };
    var result = new List<Bitmap>();
    try
    {
        await Parallel.ForEachAsync(files, po, async
            (file, _cts) =>
        {
            FileInfo fi = new(file);
            string ext = fi.Extension.ToLower();
            if (ext == ".jpg" || ext == "jpeg")
            {
                result.Add(ConvertJpgToBitmap(file));
                await Task.Delay(2000, _cts);
            }
        });
    }
    catch (OperationCanceledException e)
    {
        MessageBox.Show(e.Message);
    }
    finally
    {
        cts.Dispose();
    }
    return result;
}
```

Parallel.ForEachAsync 使用try/catch,以便捕获OperationCanceledException，取消事件处理，同时cts要释放

Parallel.Invoke
示例一：

```csharp
Parallel.Invoke(DoFirstAction, DoSectionAction);
//等同于:
List<Task> taskList = new();
taskList.Add(Task.Run(DoFirstAction));
taskList.Add(Task.Run(DoSectionAction));
Task.WaitAll(taskList.ToArray());
```

示例二：

```csharp
await Task.Run(() => Parallel.Invoke(DoFirstTask, DoSecondTask));
//等同于:    
List<Task> taskList = new();
taskList.Add(Task.Run(DoFirstAction));
taskList.Add(Task.Run(DoSectionAction));
await Task.WhenAll(taskList.ToArray());
```


###### BlockingCollection的使用
`BlockingCollection<T>`是一种常用的数据集合，实现生产消费者模式。可以作为替换`List<T>`，而不用作太多修改。可以使用`Add`添加子项，不同的地方是当有其他线程在读写时，`BlockingCollection<T>`会阻塞当前线程，如果想有timeout时间，可以使用`TryAdd()`,此方法支持取消和超时。移除子项采用`Take() or TryTake()`,后者同样可以有取消和超时。

`BlockingCollection<T>`默认情况下使用`ConcurrentQueue<T>`存储数据。也可以使用任何其它实现了`IProducerConsumerCollection<T>`接口的数据类型存储数据，如：

```csharp
var itemCollection = new BlockingCollection<string>(new 
    ConcurrentStack<string>(), 100);
    
var itemCollection = new BlockingCollection<string>(new 
    ConcurrentBag<string>(), 100);
```

`BlockingCollection<T>`可以通过方法`GetConsumingEnumerable()`获取一个迭代数据集，但这个迭代数据集中元素是可以进行消费的，迭代到数据集为空时，就完成迭代。

多个`BlockingCollection<T>`读写静态方法

```csharp
public static int AddToAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, T item);
public static int AddToAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, T item, System.Threading.CancellationToken cancellationToken);
public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, T item, TimeSpan timeout);
public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, T item, int millisecondsTimeout);
public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, T item);
```

```csharp
public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, out T? item, System.Threading.CancellationToken cancellationToken);
public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, out T? item);
public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, out T? item);
public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, out T? item, int millisecondsTimeout);
public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, out T? item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection<T>[] collections, out T? item, TimeSpan timeout);
```

```csharp
class FromToAnyDemo
{
    // Demonstrates:
    //      Bounded BlockingCollection<T>
    //      BlockingCollection<T>.TryAddToAny()
    //      BlockingCollection<T>.TryTakeFromAny()
    public static void BC_FromToAny()
    {
        BlockingCollection<int>[] bcs = new BlockingCollection<int>[2];
        bcs[0] = new BlockingCollection<int>(5); // collection bounded to 5 items
        bcs[1] = new BlockingCollection<int>(5); // collection bounded to 5 items

        // Should be able to add 10 items w/o blocking
        int numFailures = 0;
        for (int i = 0; i < 10; i++)
        {
            if (BlockingCollection<int>.TryAddToAny(bcs, i) == -1) numFailures++;
        }
        Console.WriteLine("TryAddToAny: {0} failures (should be 0)", numFailures);

        // Should be able to retrieve 10 items
        int numItems = 0;
        int item;
        while (BlockingCollection<int>.TryTakeFromAny(bcs, out item) != -1) numItems++;
        Console.WriteLine("TryTakeFromAny: retrieved {0} items (should be 10)", numItems);
    }
}
```

标记数据集不再接收对象

```csharp
public void CompleteAdding ();
```

###### Using ConcurrentBag
`ConcurrentBag<T>`是一个无序集合，类型本身提供的所有方法都是线程安全，扩展方法不保证全部线程安全。Bag数据类型允许重复数据，包括null


##### 6、多线程调试

- Threads:显示应用可调试的所有线程，同时可以看到激活断点在那个线程，Debug | Windows | Threads
    标记线程，用于过虑线程，冻结线程用于“SuspendThread or ResumeThread ”
- Parallel Stacks：Debug | Windows | Parallel Stacks
- Parallel Watch：Debug | Windows | Parallel Watch
- Debug Location:此工具栏，显示进程，线程和堆栈，View | Toolbars | Debug Location
- Tasks
- Attach to Process
- Remote debugging
- GPU Threads

##### 7、异步执行取消

###### 使用CancelToken
```csharp
public static void ProcessText(object? cancelToken)
{
    var token = cancelToken as CancellationToken?;
    string text = "";
    for (int x = 0; x < 75000; x++)
    {
        if (token != null && token.Value.IsCancellationRequested)
        {
            Console.WriteLine($"Cancellation request
                received. String value: {text}");
            break;
        }
        text += x + " ";
        Thread.Sleep(500);
    }
}
private static void CancelThread()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Starting operation.");
    ThreadPool.QueueUserWorkItem(new
        WaitCallback(ManagedThreadsExample
            .ProcessText), tokenSource.Token);
    Thread.Sleep(5000);
    Console.WriteLine("Requesting cancellation.");
    tokenSource.Cancel();
    Console.WriteLine("Cancellation requested.");
}
```

###### 并行取消

```csharp
public static void ProcessTextParallel(object?
    cancelToken)
{
    var token = cancelToken as CancellationToken?;
    if (token == null) return;
    string text = "";
    ParallelOptions options = new()
    {
        CancellationToken = token.Value,
        MaxDegreeOfParallelism =
            Environment.ProcessorCount
    };
    try
    {
        Parallel.For(0, 75000, options, (x) =>
        {
            text += x + " ";
            Thread.Sleep(500);
        });
    }
    catch (OperationCanceledException e)
    {
        Console.WriteLine($"Text value: {text}.
            {Environment.NewLine} Exception
                encountered: {e.Message}");
    }
}
private static void CancelParallelFor()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Press a key to start, then press 'x' to send cancellation.");
    Console.ReadKey();
    Task.Run(() =>
    {
        if (Console.ReadKey().KeyChar == 'x')
            tokenSource.Cancel();
        Console.WriteLine();
        Console.WriteLine("press a key");
    });
    ManagedThreadsExample.ProcessTextParallel
        (tokenSource.Token);
}
```

###### PLINQ query取消

```csharp
public static void ProcessNumsPlinq(object?
    cancelToken)
{
    int[] input = Enumerable.Range(1,
        25000000).ToArray();
    var token = cancelToken as CancellationToken?;
    if (token == null) return;
    int[]? result = null;
    try
    {
        result =
            (from value in input.AsParallel()
                .WithCancellation(token.Value)
                where value % 7 == 0
                orderby value
                select value).ToArray();
    }
    catch (OperationCanceledException e)
    {
        Console.WriteLine($"Exception encountered:
            {e.Message}");
    }
}
private static void CancelPlinq()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Press a key to start.");
    Console.ReadKey();
    Task.Run(() =>
    {
        Thread.Sleep(100);
        Console.WriteLine("Requesting cancel.");
        tokenSource.Cancel();
        Console.WriteLine("Cancel requested.");
    });
    ManagedThreadsExample.ProcessNumsPlinq
        (tokenSource.Token);
}
```

##### 8、取消模式
- OperationCanceledException
- 检查CanceltionToken的IsCancellationRequested
- registering a callback method
- Canceling with wait handles

```csharp
static void FindSmallXValues(List<Point> points, CancellationToken token)
        {
            foreach (Point point in points)
            {
                if (point.X < 50)
                {
                    Console.WriteLine($"Point with small X coordinate found.Value: {point.X}");
                }
                if (token.IsCancellationRequested) //Cancellation With Token
                {
                    break;
                }
                Thread.SpinWait(5000);
            }
        }
```

```csharp
private static async Task DownloadAudioAsync
    (CancellationToken token)
{
    const string url = "https://archive.org/download/lp_the-odyssey_homer-anthony-quayle/disc1/lp_the-odyssey_homer-anthony-quayle_disc1side1.flac";
    using WebClient webClient = new();
    token.Register(webClient.CancelAsync); //注册取消token
    try
    {
        await webClient.DownloadFileTaskAsync(url,
            GetDownloadFileName());
    }catch (WebException we)
    {
        if (we.Status == WebExceptionStatus
            .RequestCanceled)
            throw new OperationCanceledException();
    }
    catch (AggregateException ae)
    {
        foreach (Exception ex in ae.InnerExceptions)
        {
            if (ex is WebException exWeb &&
                exWeb.Status == WebExceptionStatus
                    .RequestCanceled)
                throw new OperationCanceled
                    Exception();
        }
    }
    catch (TaskCanceledException)
    {
        throw new OperationCanceledException();
    }
}
public static async Task CancelWithCallback()
{
    using CancellationTokenSource tokenSource = new();
    Console.WriteLine("Starting download");
    var task = DownloadAudioAsync(tokenSource.Token);
    tokenSource.Token.WaitHandle.WaitOne
        (TimeSpan.FromSeconds(3));
    tokenSource.Cancel();
    try
    {
        await task;
    }
    catch (OperationCanceledException ex)
    {
        Console.WriteLine($"Download canceled.
            Exception: {ex.Message}");
    }
}
```

```csharp
public static void CancelWithMultipleTokens
    (CancellationToken parentToken)
{
    using CancellationTokenSource tokenSource = new();
    using CancellationTokenSource combinedSource =  
        CancellationTokenSource.CreateLinked
           TokenSource(parentToken, tokenSource
               .Token);
    PollingExample.CancelWithPolling(combinedSource);
    Thread.Sleep(1000);
    tokenSource.Cancel();
}
```


##### 9、异步单元测试

```csharp
[Fact]
public async Task GetCustomerOrdersAsync_
    Throws_Exception_For_Invalid_CustomerId()
{
    var service = new BookOrderService();
    await Assert.ThrowsAsync<ArgumentException>(async
        () => await service.GetCustomerOrdersAsync
            (-2));
}
```

